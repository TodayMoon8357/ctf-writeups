# **Challenge:** Abnormal Maybe Illegal

**Description:** We have recently discovered tons of traffic leaving our network. We have reason to believe they are using an abnormal method. Can you figure out what data they are exfiltrating?\
**Hint 1:** TCP packets are constructed in a way, where certain combinations are possible/(legal) and others should raise alerts/(illegal).\
**Hint 2:** Now that you found the illegal packets, think more black and white.\
**Attachments:** abnormal_illegal.pcapng

**Note:** This challenge was shared with me by a close friend of mine.

**Solution:**
The attached file contains a traffic capture between two hosts. Many duplicate messages can be seen being sent to each other.

<img width="1284" height="680" alt="Screenshot 2025-08-05 165122" src="https://github.com/user-attachments/assets/ca94c9ed-20d9-4327-b205-ea2ed18565ca" />

The key in this analysis is to identify the outliers: user-modifiable details in these packets that can be used to convey information, even if it's something minute. That brought me to the first notable packet, conveniently aligning with Hint 1.

<img width="956" height="464" alt="image" src="https://github.com/user-attachments/assets/735d1a86-8083-45ce-86f7-44d9d6cc62cb" />

TCP Packets with the flag combination "FIN-SYN" are categorized as illegal; they do not occur through normal means of operation (a whole DDoS attack surrounds the technique called "SYN-FIN flooding"). The "RST" flag is an addition to the original "FIN-SYN" packet, so highlighting this detail is not as significant in this phase. I now had to identify every single illegal packet with this combination. 

<img width="1022" height="363" alt="image" src="https://github.com/user-attachments/assets/cb9351da-470c-434a-85ee-13f515d4ee39" />

128 packets contained the illegal "FIN-SYN" setup with different variations. What does one do with that information?

Hint 2 alludes to finding any binary sequence (black and white). At first, I thought it was a binary sequence generated by the color coding Wireshark made. If RED was 1 and GREY was 0, or vice versa, I could synthesize a binary string that converts to text. However, this theory was quickly busted:

1. As R=1, G=0:
    - 11001001 created a nonreadable character.
2. As R=0, G=1:
    - 00110110 created "6", but 00010101 created a nonreadable character.

I previously mentioned that identifying the outliers will lead us to the answer. All packets contained the "FIN-SYN" flags, but the flags "PSH" and "RST" alternated. Some packets had either flag on, while others had both or none on. This is where knowledge of TCP packets helps me find this solution.

<img width="1075" height="490" alt="image" src="https://github.com/user-attachments/assets/bb18fec2-70fc-434a-9955-d1eb8b01510e" />

All packets follow a specific framework/structure, allowing all devices to parse data sent over binary. These flags are merely bits in a specific position, which Wireshark identifies quickly. If I extracted each packet's "PSH" and "RST" binary digits, I could create a new binary string.

Using TShark and a little scripting with Python, I extracted the binary values of the "PSH" and "RST" flags from each packet, then synthesized the binary string from the pairs. Below are the commands I used. Since I'm familiar with them, some portions may appear lazy or summarized (especially the Python code).

CMD
```
"C:\Program Files\Wireshark\tshark.exe" -r .\abnormal_illegal.pcapng -Y "tcp.flags.syn == 1 && tcp.flags.fin == 1" -Tfields -e "tcp.flags"  > flags.txt
```
Python
```python
flags = open("flags.txt","r").read().split()
end = ""
for n in flags:
    end += "{:02b}".format(int(n[2:],16) >> 2)

f = ""
while end:
    f+= chr(int(end[:8],2))
    end = end[8:]

print(f)
```
To explain my code:
 - Command Prompt
     1. Using tshark.exe, I listed all the flag values in hexadecimal strings (the best representation of the binary data I could generate with Wireshark). After all, the order of `[PSH]-[RST]-[SYN]-[FIN]` is critical, and I needed to access bits RST and PSH (3 and 4). 
 - Python
     1. I read the values from the file and parsed all hexadecimal values.
     2. Iterating over the TCP flag values, I converted them into a numerical value, of which I could perform a bitwise shift. Performing the shift allows me to dispose of any unnecessary rightmost bits and get to bit positions 3 and 4. Conveniently, none of the packets exceed the value of decimal 16 (bit position 5). Any packet with that value would have accidentally added unnecessary binary into my final result.
     3. I concatenated the bit pairs into one long string. Eventually, I would break into groups of 8 to create a byte, which can be converted into text via ASCII encoding.
       - ex.\
         Packet 1: `01`, Packet 2: `11`, Packet 3: `00`, Packet 4: `00`\
         Packet 1-4: `01110000`, which encodes to "p", then repeat the process for all packets

256 bits later, I got the competition flag.

**Flag:** pctf{abnormal_flags_are_illegal}
